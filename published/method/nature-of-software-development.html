<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>2.4 Nature of Software Development</title>
<link href="http://fonts.googleapis.com/css?family=Fira+Sans:300,400,500,700|Inconsolata" rel="stylesheet" type="text/css" />

    <link href="http://nclverse.github.io/dissertation/css/styles.css" media="all" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <section id="container">
      <section id="sidebar"><nav id="main-nav">
  <header id="title">
    <img class="site-logo" alt="logo" src="http://nclverse.github.io/dissertation/img/logo.svg" />
    <div class="titles">
      <span class="verse-title">NCL<strong>Verse</strong></span>
      <ul class="docs-site">
        <li><a class="active" href="http://nclverse.github.io/dissertation">Dissertation</a></li>
      </ul>
    </div>
  </header>
  <div class="category">
    <header class="category-title"><h1>published<span class="count">12263 Words</span></h1></header>
    <ul class="titles">
      <li><a class="title-link">Introduction<span class="count">1409 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/introduction/acknowledgements.html">Acknowledgements<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/introduction/overview.html">Overview<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/introduction/introduction.html">Introduction<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link">Theory<span class="count">2818 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/theory/metaphors-of-the-ecosystem.html">Metaphors Of The Ecosystem<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/theory/growing-an-ecosystem.html">Growing An Ecosystem<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link active">Method<span class="count">3751 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/method/analysis.html">Analysis<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/method/implementation.html">Implementation<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/method/the-design-language.html">The Design Language<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link active" href="http://nclverse.github.io/dissertation/published/method/nature-of-software-development.html">Nature Of Software Development<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/method/research.html">Research<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link">Discussion<span class="count">2298 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/the-fragmented-ecosystem.html">The Fragmented Ecosystem<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/ivory-tower.html">Ivory Tower<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/exam-sieve.html">Exam Sieve<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/progress-mate.html">Progress Mate<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/curriculum.html">Curriculum<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/student-pad.html">Student Pad<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/discussion/dashboard.html">Dashboard<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link">Evaluation<span class="count">1358 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/evaluation/evaluation.html">Evaluation<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/evaluation/results.html">Results<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/evaluation/learnings.html">Learnings<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link">Coda<span class="count">629 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/coda/looking-back.html">Looking Back<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/coda/future.html">Future<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/published/coda/bibliography.html">Bibliography<span class="count"></span></a></li></ul>
      </li>
      </ul>
  </div><div class="category">
    <header class="category-title"><h1>knowledge-repo<span class="count">3688 Words</span></h1></header>
    <ul class="titles">
      <li><a class="title-link">After Math<span class="count">11 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/knowledge-repo/after-math/afterword.html">Afterword<span class="count"></span></a></li></ul>
      </li>
      </ul><ul class="titles">
      <li><a class="title-link">Resources<span class="count">3677 Words</span></a>
        <ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/knowledge-repo/resources/half-baked.html">Half Baked<span class="count"></span></a></li></ul><ul class="subtitles"><li> <a class="subtitle-link" href="http://nclverse.github.io/dissertation/knowledge-repo/resources/threads.html">Threads<span class="count"></span></a></li></ul>
      </li>
      </ul>
  </div>

</nav></section>
      <section id="read-area"><article class="post">
  <section class="content">
<div id="outline-container-sec-1" class="outline-1">
<h1 id="sec-1">2.4 Nature of Software Development</h1>
<div class="outline-text-1" id="text-1">
<p>
Building software is a continuous decision making process. Software
is repeatedly hit by wavefronts of changes initiated by multiple
agents. Hence, it was of utmost importance that the philosophy and
the principles laid out here would not stand in the way of
adaptability of the system. This was held as the central principle
behind structuring the system or in other words ability to adapt
change is the major parameter worth benchmarking the efficacy of
this architecture against.
</p>
</div>


<div id="outline-container-sec-1-1" class="outline-2">
<h2 id="sec-1-1">2.4.1 Developing the Architecture</h2>
<div class="outline-text-2" id="text-1-1">
<p>
Architecture is defined as "the process and product of planning,
designing and constructing buildings." Buildings here can be
substituted for software without losing much in intend.
</p>

<blockquote>
<p>

There are only two hard things in Computer Science: Cache
Invalidation and Naming Things. - Phil Karlton
</p>
</blockquote>

<p>
Software systems are complex because of the fact that there are a
lot of entities and myriads of relationships among them. Inorder to
have a control in creating systems as they grow complex, it was
essential that recurrent patterns were spotted and given a name to,
so that it helped to manipulate and reason about these concepts.
As the size of the systems in the current project started growing
one of the biggest challenges came in the form of having to name
things. It was one of the increasingly difficult concepts to
minimize the name clashes as and keep them separated apart so that
there was no confusion.
</p>

<p>
Fred Brooke's in his book argues that coherent systems are the
one's where the whole system can be kept in ones' mind as noted by
Fred Brooks. As he notes, it became increasingly difficult when it
came to the naming aspect to keep all of this in my mind.
</p>

<p>
Inorder to construct an architecture, a language haS to be
developed to talk about it. This made the architecture tangible and
provides an unambiguous description of architectural building
blocks as well as concrete system while abstracted away from
implementation details.
</p>

<p>
The architecture required definition of the building blocks (types
of things) from which the actual system will be built. It can be
thought of as a bespoke language constructed in order to talk about
the system. Though I couldn't take it to a fuller refinement, I
have provided systems diagrams [provide crosslink] to explain the
construction of the software created for the ecosystem.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-2">
<h2 id="sec-1-2">2.4.2 Choosing a programming language (Read)</h2>
<div class="outline-text-2" id="text-1-2">
<blockquote>
<p>

 Controlling complexity is the essence of computer programming.
 — Brian Kernighan
</p>
</blockquote>

<p>
Software development is an enterprise that is deeply enmeshed with
controlling complexity has been one of the pivotal concerns in this
project. As Djikstra points out "computing scientist’s main
challenge is not to get confused by the complexities of his own
making", this rang quite true throughout this project.
</p>

<p>
Almost all of this project was completed in a programming language
known as Clojure. It's a Lisp that runs on the JVM. As of the
writing it has emerged as the most popular lisp ever written. But
popularity can't be held as an indicator of quality. What I feel is
a good indicator is the ease with which a tool enables creation and
in this regard Clojure proved to be a solid tool to build software
systems. I am convinced that the nature of minimal syntax of Lisp
and composability of mathematical functions are great concepts to
manage the emergent complexity when developing software. The great
tooling around the core language and an active and smart community
around the language have been pivotal towards this achievement. The
lanugage being functional in nature also helped me learn a lot
about programming in general since my education at the university
was heavily focused towards object oriented and imperative
languages. Simply put, it has been transformative in more ways than
one. Simple core abstractions, immutability, referential
transparency and a whole lot of other great concepts that Clojure
entails have greatly shaped the way I program and I hope will
continue to influence my future. Implications of developing in a
functional paradigm is mentioned in the methods section.
</p>

<p>
A note that that I have to add about Clojure is that it simply
doesn't make the software development process easy for you. It is
simply not so for an incoming newbie. You have to be well versed on
a large pool of concepts to help it to see the programming domain
in the way it sees but once you are beyond that plateau, leveraging
Clojure leads to a simplified view of creating processes and
procedures.
</p>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-2">
<h2 id="sec-1-3">2.4.3 Shape of the systems</h2>
<div class="outline-text-2" id="text-1-3">
<p>
Describe the steps taken in order to making the systems legible.
</p>
</div>
</div>


<div id="outline-container-sec-1-4" class="outline-2">
<h2 id="sec-1-4">2.4.4 Dogfooding (Rewrite)</h2>
<div class="outline-text-2" id="text-1-4">
<p>
There is a concept known as dogfooding which means to test the
software by yourself. Since I am one among the target audience for
which I'm constructing this system for, it was a natural fit. But
instead of focusing on how these helped inform my academic
decisions which I'm relegating to the evaluation section I will
briefly mention how I got a good taste of this when I used my
docs-gen [NVDocsGen 2015] [link] to generate the documentation for describing
the apps in the ecosystem. It was a good experience to create
software that describe the docs generator. This was a good
benchmark to test the soundness of the concept as you continuously
used the software yourself while also presenting an alternative
view, I made sure that I shared my creations with my colleagues to
see the sticking points or potentially confusing interactions that
might arise.
</p>
</div>
</div>


<div id="outline-container-sec-1-5" class="outline-2">
<h2 id="sec-1-5">2.4.5 Componentized apps (Reread)</h2>
<div class="outline-text-2" id="text-1-5">
<p>
Systems had to be constructed with the idea that specifications
would always change. And as the saying goes change being the only
thing that is constant, it was high priority to build this
ecosystem in a manner that it accommodated change. This has been
achieved by keeping the systems modular.
</p>

<p>
The nature of lisp lends itself to create components which can be
weaved together to form a whole app. I could only fare as far as
creating structures of web components as outlined in the
development section, but some more work is to be done in order to
make it truly componentized. This means that apps can be composed
as a series of higher order functions.
</p>

<p>
One of the central precepts of this dissertation is that of
modularization and all the apps can be considered as an module that
consists of further more modules inside them.  Due to my limited
time and experience I had with lisp this has not been realized to a
fuller extend in this project but to give a brief account of how
this can be enabled, here's some very minimal Clojure code that
uses the compose function in Clojure.
</p>

<div class="org-src-container">

<div class="highlight"><pre><span class="c1">; Comp(ose)ing the components together</span>

<span class="p">(</span><span class="k">def </span><span class="nv">app</span> <span class="p">((</span><span class="nf">comp</span><span class="p">)</span> <span class="nv">header</span> <span class="nv">main-area</span> <span class="nv">footer</span><span class="p">))</span>

<span class="c1">; Passing in the data (app data)</span>
</pre></div>

</div>

<p>
This would help enable the componentization and hence reuse of
different modules developed for each app among the different apps
</p>
</div>
</div>


<div id="outline-container-sec-1-6" class="outline-2">
<h2 id="sec-1-6">2.4.6 Software eats itself. (Reread and Illustrate)</h2>
<div class="outline-text-2" id="text-1-6">
<p>
Better abstractions enable structuring your programs
better. Throughout the process I was able to see how a thorough
abstraction of a certain model of process enabled me to be more
flexible at designing my functions. In order to give a simple
illustration:
</p>

<p>
The code
</p>

<p>
(def )
</p>

<p>
whereas if I employ the following code:
</p>

<p>
(def )
</p>

<p>
would result in much more flexibility in terms of the actual
product. This was proven time and again throughout the time I did
my dissertation.
</p>

<p>
One way is to start from scratch and supply as much
care and control over everything by building them from the ground
up but the scope of this dissertation as it had to be produced in
a limited time didn't allow for such levels of explorations. I
have to mention that the language adopted for building this
ecosystem played a key part in keeping the complexity to a
manageable level. Also, this nature of software being always in
flux is what lead me to create the current architecture of
centralizing it with the pervasive model of Internet technology -
the client server model.
</p>
</div>
</div>


<div id="outline-container-sec-1-7" class="outline-2">
<h2 id="sec-1-7">2.4.7 Advantages</h2>
<div class="outline-text-2" id="text-1-7">
<p>
It was essential to follow certain models and probably I have tried
to explore different sets of architectural styles for each
apps. For example the ExamVault website follows a typical client
server model with most of the visual rendering predetermined on the
server side whereas in NCLProgress the majority is done on the
client side, similarly for IvoryTower which forms the backbone of
apps by providing them data uses a RESTful architecture in
delivering the information. I will be detailing about these styles
later in fuller detail later in the thesis but it is to be noted
that modularizing the apps and creating a domain for a coherent set
of functionality enables the exploration of creating bespoke
architectures that are well fitted to each domain. This could be a
major win from a polyglot perspective as I have mentioned this
enables for integrating newer systems into the ecosystem with ease.
</p>
</div>
</div>


<div id="outline-container-sec-1-8" class="outline-2">
<h2 id="sec-1-8">2.4.8 Tradeoffs made</h2>
</div>


<div id="outline-container-sec-1-9" class="outline-2">
<h2 id="sec-1-9">2.4.9 Towards better architectures</h2>
<div class="outline-text-2" id="text-1-9">
<p>
Lack of my knowledge with respect to software architectures in
general and inability to visualize the future of these apps have
rendered to this to be sub-optimal but the good thing about
software is that everything can be rebuilt from scratch once you
have explored the domain space thoroughly.
</p>

<p>
A few structures that I have in mind to architecture the ecosystem
was Supervisor-Workers model from Erlang OTP documentation.
Attention had to be paid to the behaviour of this software. I have
decided that if further work is to be carried out if I wants to
create a completely resilient system.  The implications of adopting
this model is further explained in the [future] section.
</p>
</div>
</div>


<div id="outline-container-sec-1-10" class="outline-2">
<h2 id="sec-1-10">Notes to self</h2>
<div class="outline-text-2" id="text-1-10">
<p>
Fred Brookes' tar pit.  Silos and Snowclones.
</p>
</div>
</div>
</div>
</section>

</article></section>
    </section>
  </body>

</html>